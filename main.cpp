
#include <iostream>
#include <bits/stdc++.h>
#include <pthread.h>
#include <string>
#include <vector>

// Huffman tree node that stores data and frequency of each character
struct HuffNode
{
    char data;
    unsigned freq;
    unsigned seq;
    HuffNode *left, *right;

    HuffNode(char data, unsigned freq, unsigned seq)
    {
        left = right = NULL;
        this->data = data;
        this->freq = freq;
        this->seq = seq;
    }
    ~HuffNode() {}
};

// Struct for passing arguments to threads
struct Argument
{
    std::string code;
    std::vector<int> pos;
    char *arr;
    HuffNode *tree;
};

// Prints huffman codes by traversing down the huffman tree
void printCodes(struct HuffNode *root, std::string str)
{
    if (!root)
        return;

    if (root->data != '\0')
        std::cout << "Symbol: " << root->data << ", Frequency: " << root->freq << ", Code: " << str << std::endl;

    printCodes(root->left, str + "0");
    printCodes(root->right, str + "1");
}

// This function inserts the newly generated HuffNode into its correct position in the HuffNode vector
void sorted_insert(std::vector<HuffNode *> &arr, HuffNode *x)
{
    int i = 0;
    bool inserted = false;
    while (!inserted)
    {
        // First, we compare the frequncy of the new node and insert it accordingly
        if (arr[i]->freq > x->freq)
        {
            arr.insert(arr.begin() + i, x);
            inserted = true;
        }
        // If the frequency is the same, we compare the data and insert it accordingly
        else if (arr[i]->freq == x->freq && arr[i]->data > x->data)
        {
            arr.insert(arr.begin() + i, x);
            inserted = true;
        }
        // If both the frequency and data are the same, then we compare when these nodes were generated by comparing the seq and insert accordingly
        else if (arr[i]->freq == x->freq && arr[i]->data == x->data && arr[i]->seq < x->seq)
        {
            arr.insert(arr.begin() + i, x);
            inserted = true;
        }
        // If the new node is not inserted even after comparing all the values, it is inserted at the end of the vector
        else if (i == arr.size())
        {
            arr.push_back(x);
            inserted = true;
        }
        // compare the node to the next element in the vector
        else
        {
            i++;
        }
    }
}

// Sort the two vectors from the first file by their frequency and data
void Initial_sort(std::vector<char> &symb, std::vector<int> &freq)
{
    for (int i = 0; i < symb.size() - 1; i++)
    {
        for (int j = i + 1; j < symb.size(); j++)
        {
            if (freq[j] < freq[i])
            {
                std::swap(symb[i], symb[j]);
                std::swap(freq[i], freq[j]);
            }
            else if (freq[j] == freq[i] && symb[j] < symb[i])
            {
                std::swap(symb[i], symb[j]);
                std::swap(freq[i], freq[j]);
            }
        }
    }
}

// Main huffman tree function that takes an array of frequencies and characters to generate a huffman tree and returns a pointer to the generated tree
HuffNode *Generate_Huffman_tree(std::vector<char> &data, std::vector<int> &freq)
{
    struct HuffNode *left, *right, *top;

    // Generate the Initial vector of Nodes and populate it with appropriate Symbols and their respective frequencies
    std::vector<HuffNode *> NodeVector;
    int seq; // This variable marks the sequence in which the elements of the huffman tree are generated and inserted
    for (seq = 0; seq < data.size(); seq++)
        NodeVector.push_back(new HuffNode(data[seq], freq[seq], seq));

    // Generate the huffman tree until there is only a single node left in the NodeVector vector
    while (NodeVector.size() != 1)
    {
        left = NodeVector.front();
        NodeVector.erase(NodeVector.begin());
        right = NodeVector.front();
        NodeVector.erase(NodeVector.begin());

        top = new HuffNode('\0', left->freq + right->freq, seq);
        seq++;

        top->left = left;
        top->right = right;

        sorted_insert(NodeVector, top); // Insert the top by comparing it with other elements in NodeVector
    }
    printCodes(NodeVector.front(), "");
    return NodeVector.front();
}

// This function recieves a string and outputs the character in front of the string
char extractSymb(std::string &line)
{
    char symb = line.at(0);
    return symb;
}

// This function recieves a string and outputs the frequency of that character
int extractInt(std::string &line)
{
    line.erase(0, 2);
    int x = stoi(line);
    return x;
}

// this function receives a string and returns the code of a character
std::string extractCode(std::string &line)
{
    std::string code = "";
    while (line.at(0) != ' ')
    {
        code.push_back(line.at(0));
        line.erase(0, 1);
    }
    line.erase(0, 1);
    return code;
}

// this function receives a string and return a vector array of the positions that the character should be placed in
std::vector<int> extractIndex(std::string &line, int &count)
{
    std::vector<int> arr;
    int x = 0;
    for (int i = 0; i < line.size(); i++)
    {
        if (line.at(i) != ' ')
            x = (x * 10) + (line.at(i) - 48);

        if (line.at(i) == ' ' || i == (line.size() - 1))
        {
            arr.push_back(x);
            x = 0;
            count++;
        }
    }
    return arr;
}

// This function traverses the huffman tree and outputs a character associated with the inputted code
char traverse(struct HuffNode *root, std::string &code)
{
    char a;
    if (root->data != '\0')
    {
        a = root->data;
        return a;
    }

    while (!code.empty())
    {
        if (code.at(0) == '0')
        {
            code.erase(0, 1);
            return traverse(root->left, code);
        }
        if (code.at(0) == '1')
        {
            code.erase(0, 1);
            return traverse(root->right, code);
        }
    }
    return a;
}

// This function would receive the threads and store the characters in their proper position using a pointer to a character array
void *prepare_message(void *decode_void_ptr)
{
    struct Argument *arg_ptr = (struct Argument *)decode_void_ptr;
    int size = arg_ptr->pos.size();
    char alpha = traverse(arg_ptr->tree, arg_ptr->code);
    for (int i = 0; i < size; i++)
    {
        int index = arg_ptr->pos[i];
        arg_ptr->arr[index] = alpha;
    }
    return NULL;
}

// This function receives the pointer to the top of the huffman tree and deallocates the memory allocated to each node by travering the huffman tree
bool release(HuffNode *top)
{
    if (top->left == NULL && top->right == NULL)
    {
        return true;
    }

    bool leftflag, rightflag;
    leftflag = release(top->left);
    rightflag = release(top->right);

    if (leftflag && rightflag)
    {
        delete top->left;
        delete top->right;
        return true;
    }

    return true;
}

// the main body of the function
int main()
{
    std::vector<char> symb;
    std::vector<int> freq;
    HuffNode *tree;
    int m = 0;     // This variable stores how many threads need to be generated
    int count = 0; // This variable stores how many characters there are in the final message
    std::string input, line;

    // store the values from the first file in symb and freq arrays
    std::cin >> input;
    std::ifstream infile(input);
    if (infile.is_open())
    {
        while (getline(infile, line))
        {
            symb.push_back(extractSymb(line));
            freq.push_back(extractInt(line));
            m++;
        }
    }
    infile.close();
    infile.clear();

    // Sort the 2 vectors
    Initial_sort(symb, freq);

    // Generate the huffman tree and store the address of the generated tree in the tree pointer
    tree = Generate_Huffman_tree(symb, freq);
    static struct Argument *Arguments = new Argument[m];
    m = 0;

    // Store the values of the second file in the location that Arguments points to
    std::cin >> input;
    infile.open(input);

    if (infile.is_open())
    {
        while (getline(infile, line))
        {
            Arguments[m].code = extractCode(line);
            Arguments[m].pos = extractIndex(line, count);
            Arguments[m].tree = tree;
            m++;
        }
    }
    infile.close();
    infile.clear();

    // Generate the array that will store the final message and pass it to Arguments
    char final[count];
    for (int i = 0; i < m; i++)
        Arguments[i].arr = final;

    // Generate m threads
    pthread_t tid[m];

    // pass m threads to prepare_message function that would store required characters in the final string
    for (int i = 0; i < m; i++)
    {
        if (pthread_create(&tid[i], NULL, prepare_message, &Arguments[i]))
        {
            fprintf(stderr, "Error creating thread\n");
            return 1;
        }
    }

    // Merge all the generated threads
    for (int i = 0; i < m; i++)
        pthread_join(tid[i], NULL);

    // print the Original message
    std::cout << "Original message: ";
    for (int i = 0; i < count; i++)
        std::cout << final[i];
    std::cout << std::endl;

    // Release the memory allocated to different variables
    release(tree);
    delete tree;
    delete[] Arguments;

    return 0;
}